\documentclass{article}

% \usepackage[dutch]{babel}
\usepackage{color,courier,fancyhdr,listings,parcolumns,verbatim}
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}

\title{TCR}
\author{git diff solution (Jens Heuseveldt, Ludo Pulles, Peter Ypma)}

\lstset{
	basicstyle=\footnotesize\ttfamily,
	breaklines=true,
	commentstyle=\color[rgb]{0.5,0.5,0.5},
	frame=lines,
	keywordstyle=\color{blue},
	language=C++,
	numbers=left,
	numbersep=5pt,
	numberstyle=\tiny\color[rgb]{0.6,0.6,0.6},
	otherkeywords={cin, cout, cerr, pii, pll, PI, INF, LLINF, NUM},
	showstringspaces=false,
	stringstyle=\color[rgb]{0.6,0.3,0},
	tabsize=4,
	xleftmargin=\parindent
}

\pagestyle{fancy}
\lhead{Utrecht University}
\rhead{git diff solution}

\begin{document}

\maketitle
\begin{center}
	\makeatletter
	\textbf{\@title} \\
	\today \\
	\emph{\@author}
	\makeatother
\end{center}

\tableofcontents
% \newpage

\begin{center}
vim {\raise.17ex\hbox{$\scriptstyle\sim$}}/.vimrc
\end{center}

\begin{lstlisting}[]
set nu sw=4 ts=4 noet ai hls
syntax on
colorscheme slate
\end{lstlisting}

\begin{center}
template.cpp
\end{center}

\begin{lstlisting}
#include<bits/stdc++.h>

#define x first
#define y second

using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;

const int INF = 2147483647; // (1 << 30) - 1 + (1 << 30)
const ll LLINF = (1LL << 62) - 1 + (1LL << 62); // = 9.223.372.036.854.775.807
const double PI = acos(-1.0);

// lambda-expression: [] (args) -> retType { body }

const bool LOG = false;
void Log() { if(LOG) cerr << "\n\n"; }
template<class T, class... S>
void Log(T t, S... s) {
	if(LOG) cerr << t << "\t", Log(s...);
}

template<class T1, class T2>
ostream& operator<<(ostream& out, const pair<T1,T2> &p) {
	return out << '(' << p.x << ", " << p.y << ')';
}

template<typename T1, typename T2>
ostream& operator<<(ostream &out, pair<T1, T2> p) {
	return out << "(" << p.x << ", " << p.y << ")";
}

template<class T>
using min_queue = priority_queue<T, vector<T>, greater<T>>;

// Order Statistics Tree (if this is supported by the judge software)
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
template<class TIn, class TOut> // key, value types. TOut can be null_type
using order_tree = tree<TIn, TOut, less<TIn>,
	rb_tree_tag, tree_order_statistics_node_update>;
// find_by_order(int r) (0-based)
// order_of_key(TIn v)
// use key pair<Tin,int> {value, counter} for multiset/multimap

int main() {
	ios_base::sync_with_stdio(false); // faster IO
	cin.tie(NULL);                    // faster IO
	cerr << boolalpha;                // (print true/false)
	(cout << fixed).precision(10);    // set floating point precision
	// TODO: code
	return 0;
}
\end{lstlisting}

Prime numbers: $\mathit{982451653}$, $\mathit{81253449}$, $10^3 + \{-9,-3,9,13\}$, $10^6 + \{-17, 3, 33\}$, $10^9 + \{7,9,21,33,87\}$

\subsection{De winnende aanpak}

\begin{itemize}
	\setlength\itemsep{-.25em}
	\item Goed slapen \& een vroeg ritme hebben
	\item Genoeg drinken \& eten tijdens de wedstrijd
	\item Een lijst van alle problemen met info waar het over gaat, en wie het goed kan oplossen
	\item Ludo moet de opgave goed lezen
	\item Test de kleine voorbeeldgevallen
	\item Houd na 2 uur een pauze en overleg waar iedereen mee bezig is
	\item Maak zelf wat test-cases
	\item Na een WA, print het probleem, en probeer het ook weg te leggen
	\item Typ de dingen uit de TCR, die je zeker nodig hebt, alvast in
	\item Peter moet meer papier gebruiken om fouten te verkomen
	\item Als iemand niks te doen heeft, kan hij nodige dingen uit de TCR typen.
	\item We moeten ook een voorbeeld test-case voor TCR algoritmes hebben om te testen of het goed overgetypt is
	\item Bij geometrie moeten we om kunnen gaan met meerdere input manieren (voor bv. lijnen)
	\item Gebruik veel long long`s
	\item Bij een verkeerd antwoord, kijk naar genoeg debug output
\end{itemize}

\subsection{Detecting overflow}
These are GNU builtins, detect both over- and underflow. Returns a boolean upon failure, otherwise the result is present in \texttt{ref}. Follow the template: 

\texttt{\_\_builtin\_[u|s][add|mul|sub](ll)?\_overflow(in, out, \&ref)} 

\subsection{Wrong Answer}

\begin{itemize}
	\setlength\itemsep{-.25em}
	\item Edge cases: $n\in\{-1,0,1,2\}$. Empty list/graph?
	\item Beware of typos
	\item Test sample input; make custom testcases
	\item Read carefully
	\item Check bounds (use long long or long double)
	\item Off by one error (in indices or loop bounds)
	\item Not enough precision
	\item Assertions
	\item Missing modulo operators
	\item Cases that need a (completely) different approach
\end{itemize}

\subsection{Covering problems}

\begin{center}
	\emph{Minimum edge cover$\iff$Maximum independent set}
\end{center}

\begin{description}
	\setlength\itemsep{-.25em}
	\item[Matching]
		A set of edges without common vertices \textit{(Maximum is the \textbf{largest} such set, maximal is a set which you cannot add more edges to without breaking the property)}.
	\item[Minimum Vertex Cover]
		A set vertices (cover) such that each edge in the graph is incident to at least one vertex of the set.
	\item[Minimum Edge Cover]
		A set of edges (cover) such that every vertex is incident to at least one edge of the set.
	\item[Maximum Independent Set]
		A set of vertices in a graph such that no two of them are adjacent.
	\item[K\"{o}nig's theorem]
		In any bipartite graph, the number of edges in a maximum matching equals the number of vertices in a minimum vertex cover
\end{description}

\begin{comment}
\subsection{Game theory}

A game can be reduced to Nim if it is a finite impartial game. Nim and its variants include:
\begin{description}
	\item[Nim] Let $X = \bigoplus_{i=1}^n x_i$, then $(x_i)_{i=1}^n$ is a winning position iff $X\neq 0$. Find a move by picking $k$ such that $x_k > x_k \oplus X$.
	\item[Mis\`{e}re Nim] Regular Nim, except that the last player to move \textit{loses}. Play regular Nim until there is only one pile of size larger than $1$, reduce it to $0$ or $1$ such that there is an odd number of piles.
	\item[Staricase Nim] Stones are moved down a staircase and only removed from the last pile. $(x_i)_{i=1}^n$ is an $L$-position if $(x_{2i-1})_{i=1}^{n/2}$ is (i.e. only look at odd-numbered piles).
	\item[Moore's Nim$_k$] The player may remove from at most $k$ piles (Nim $=$ Nim$_1$). Expand the piles in base $2$, do a carry-less addition in base $k+1$ (i.e. the number of ones in each column should be divisible by $k+1$).
	\item[Dim$^+$] The number of removed stones must be a divisor of the pile size. The Sprague-Grundy function is $k+1$ where $2^k$ is the largest power of $2$ dividing the pile size.
	\item[Aliquot game] Same as above, except the divisor should be proper (hence $1$ is also a terminal state, but watch out for size $0$ piles). Now the Sprague-Grundy function is just $k$.
	\item[Nim (at most half)] Write $n+1 = 2^my$ with $m$ maximal, then the Sprague-Grundy function of $n$ is $(y - 1) / 2$.
	\item[Lasker's Nim] Players may alternatively split a pile into two new non-empty piles. $g(4k+1) = 4k+1$, $g(4k+2) = 4k+2$, $g(4k+3) = 4k+4$, $g(4k+4) = 4k+3$ ($k\geq 0$).
	\item[Hackenbush on trees] A tree with stalks $(x_i)_{i=1}^n$ may be replaced with a single stalk with length $\bigoplus_{i=1}^n x_i$.
\end{description}
\end{comment}

A useful identity: $\bigoplus_{x=0}^{a - 1} x = \{0, a - 1, 1, a\}[a \, \mathrm{mod} \, 4]$.



\section{Mathematics}

\begin{lstlisting}
int abs(int x) { return x > 0 ? x : -x; }
int sign(int x) { return (x > 0) - (x < 0); }

// greatest common divisor
ll gcd(ll a, ll b) { while (b) { a %= b; swap(a, b); } return a };
// least common multiple
ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }
ll mod(ll a, ll m) { return ((a % b) + b) % b; }

// safe multiplication (ab % m) for m <= 4e18 in O(log b)
ll modmul(ll a, ll b, ll m) {
	ll r = 0;
	while (b) {
		if (b & 1) r = mod(r + a, m);
		a = mod(a + a, m);
		b >>= 1;
	}
	return r;
}

// safe exponentation (a^b % m) for m <= 2e9 in O(log b)
ll modpow(ll a, ll b, ll m) {
	ll r = 1;
	while (b) {
		if (b & 1) r = (r * a) % m;
		a = (a * a) % m;
		b >>= 1;
	}
	return r;
}

// returns x, y such that ax + by = gcd(a, b)
ll egcd(ll a, ll b, ll &x, ll &y)
{
	ll xx = y = 0, yy = x = 1;
	while (b) {
		x -= a / b * xx; swap(x, xx);
		y -= a / b * yy; swap(y, yy);
		a %= b; swap(a, b);
	}
	return a;
}

// Chinese remainder theorem
const pll NO_SOLUTION(0, -1);
// Returns (u, v) such that x = u % v <=> x = a % n and x = b % m
pll crt(ll a, ll n, ll b, ll m)
{
	ll s, t, d = egcd(n, m, s, t), nm = n * m;
	if (mod(a - b, d)) return NO_SOLUTION;
	return pll(mod(s * b * n + t * a * m, nm) / d, nm / d);
	/* when n, m > 10^6, avoid overflow:
	return pll(mod(modmul(modmul(s, b, nm), n, nm) + 
				   modmul(modmul(t, a, nm), m, nm), nm) / d, nm / d); */
}

int phi[N]; // phi[i] = #{ j | gcd(i, j) = 1 }

void sievePhi() {
	for (int i = 0; i < N; i++) phi[i] = i;
	for (int i = 2; i < N; i++)
		if (phi[i] == i)
			for (int j = i; j < N; j += i)
				phi[j] -= phi[j] / i * (i - 1);
}

// calculate nCk % p (p prime!)
ll lucas(ll n, ll k, ll p) {
	ll ans = 1;
	while (n) {
		ll np = n % p, kp = k % p;
		if (np < kp) return 0;
		ans = mod(ans * binom(np, kp), p); // (np C kp)
		n /= p; k /= p;
	}
	return ans;
}
\end{lstlisting}

\section{Datastructures}
\subsection{Segment tree $\mathcal{O}(\log n)$}

\begin{lstlisting}
typedef /* Tree element */ S;
const int n = 1 << 20;
S t[2 * n];

// sum segment tree
S combine(S l, S r) { return l + r; }
// max segment tree
S combine(S l, S r) { return max(l, r); }

void build() {
	for (int i = n; --i > 0; )
		t[i] = combine(t[2 * i], t[2 * i + 1]);
}

// set value v on position p
void update(int p, int v) {
	for (t[p += n] = v; p /= 2; )
		t[p] = combine(t[2 * p], t[2 * p + 1]);
}

// sum on interval [l, r)
S query(int l, int r) {
	S resL, resR;
	for (l += n, r += n; l < r; l /= 2, r /= 2) {
		if (l & 1) resL = combine(resL, t[l++]);
		if (r & 1) resR = combine(t[--r], resR);
	}
	return combine(resL, resR);
}
\end{lstlisting}

\subsection{Binary Indexed Tree $\mathcal{O}(\log n)$}

Use one-based indices!

\begin{lstlisting}
int bit[MAXN];

// arr[idx] += val
void update(int idx, int val) {
	while (idx < MAXN) bit[idx] += val, idx += idx & -idx;
}

// returns sum of arr[i], where i: [1, idx]
int query(int idx) {
	int ret = 0;
	while (idx) ret += bit[idx], idx -= idx & -idx;
	return ret;
}
\end{lstlisting}

\subsection{Trie}

\begin{lstlisting}
const int SIGMA = 26;

struct trie {
	bool word;
	trie **child;

	trie() : word(false), child(new trie*[SIGMA]) {
		for (int i = 0; i < SIGMA; i++) child[i] = NULL;
	}

	void addWord(const string &str)
	{
		trie *cur = this;
		for (char ch : str) {
			int idx = ch - 'a';
			if (!cur->child[idx]) cur->child[idx] = new trie();
			cur = cur->child[idx];
		}
		cur->word = true;
	}

	bool isWord(const string &str)
	{
		trie *cur = this;
		for (char ch : str) {
			int idx = ch - 'a';
			if (!cur->child[idx]) return false;
			cur = cur->child[idx];
		}
		return cur->word;
	}
};
\end{lstlisting}

\subsection{Disjoint-Set / Union-Find $\mathcal{O}(\alpha (n))$}

\begin{lstlisting}
int par[MAXN], rnk[MAXN];

void uf_init(int n) {
	fill_n(par, n, -1);
	fill_n(rnk, n, 0);
}

int uf_find(int v) {
	return par[v] < 0 ? v : par[v] = uf_find(par[v]);
}

void uf_union(int a, int b) {
	if ((a = uf_find(a)) == (b = uf_find(b))) return;
	if (rnk[a] < rnk[b]) swap(a, b);
	if (rnk[a] == rnk[b]) rnk[a]++;
	par[b] = a;
}
\end{lstlisting}

\section{Graph Algorithms}
\subsection{Maximum matching $\mathcal{O}(n m)$}

This problem could be solved with a flow algorithm like Dinic's algorithm which runs in $\mathcal{O} (\sqrt{V} E)$, too.

\begin{lstlisting}
const int nodesLeft = 1e4, nodesRight = 1e4;
bool vis[nodesRight]; // vis[rightnodes]
int par[nodesRight]; // par[rightnode] = leftnode
vector<int> adj[nodesLeft]; // adj[leftnode][i] = rightnode

bool match(int cur) {
	for (int nxt : adj[cur]) {
		if (vis[nxt]) continue;
		vis[nxt] = true;
		if (par[nxt] == -1 || match(par[nxt])) {
			par[nxt] = cur;
			return true;
		}
	}
	return false;
}

// perfect matching iff matches == nodesLeft && matches == nodesRight
int maxmatch() {
	int matches = 0;
	for (int i = 0; i < nodesLeft; i++) {
		fill_n(vis, nodesRight, false);
		if (match(i)) matches++;
	}
	return matches;
}
\end{lstlisting}

\subsection{Strongly Connected Components $\mathcal{O}(V + E)$}

\begin{lstlisting}
vector<vi> adj, comps;
vi tidx, lnk, cnr, st;
vector<bool> vis;
int age, ncomps;

void tarjan(int v) {
	tidx[v] = lnk[v] = ++age;
	vis[v] = true;
	st.push_back(v);

	for (int w : adj[v]) {
		if (!tidx[w]) tarjan(w), lnk[v] = min(lnk[v], lnk[w]);
		else if (vis[w]) lnk[v] = min(lnk[v], tidx[w]);
	}

	if (lnk[v] != tidx[v]) return;

	comps.push_back(vi());
	int w;
	do {
		vis[w = st.back()] = false;
		cnr[w] = ncomps;
		comps.back().push_back(w);
		st.pop_back();
	} while (w != v);
	ncomps++;
}

void findComps(int n) {
	age = ncomps = 0;
	vis.assign(n, false);
	tidx.assign(n, 0);
	lnk.resize(n);
	cnr.resize(n);
	comps.clear();

	for (int i = 0; i < n; i++)
		if (tidx[i] == 0) tarjan(i);
}
\end{lstlisting}

\subsubsection{2-SAT $\mathcal{O}(V+E)$}

\begin{lstlisting}
void init2sat(int n) { adj.assign(2 * n, vi()); }

// vl, vr = true -> variable l, variable r should be negated.
void imply(int xl, bool vl, int xr, bool vr) {
	adj[2 * xl + vl].push_back(2 * xr + vr);
	adj[2 * xr +!vr].push_back(2 * xl +!vl);
}

void satOr(int xl, bool vl, int xr, bool vr) {
	imply(xl, !vl, xr, vr);
}
void satConst(int x, bool v) {
	imply(x, !v, x, v);
}
void satIff(int xl, bool vl, int xr, bool vr) {
	imply(xl, vl, xr, vr);
	imply(xr, vr, xl, vl);
}

bool solve2sat(int n, vector<bool> &sol) {
	findComps(2 * n);
	for (int i = 0; i < n; i++)
		if (cnr[2 * i] == cnr[2 * i + 1]) return false;
	vector<bool> seen(n, false);
	sol.assign(n, false);
	for (vi &comp : comps) {
		for (int v : comp) {
			if (seen[v / 2]) continue;
			seen[v / 2] = true;
			sol[v / 2] = v & 1;
		}
	}
	return true;
}
\end{lstlisting}

\begin{comment}
\subsection{Cycle Detection $\mathcal{O}(V + E)$}

\begin{lstlisting}
vector<vi> adj; // assumes bidirected graph, adjust accordingly
vector<bool> vis(MAXN, false);
vector<int> par(MAXN, -1);

bool cycle_detection() {
	stack<int> s;
	s.push(0);
	vis[0] = true;
	while(!s.empty()) {
		int cur = s.top();
		s.pop();
		for(int i : adj[cur]) {
			if(vis[i] && par[cur] != i) return true;
			s.push(i);
			par[i] = cur;
			vis[i] = true;
		}
	}
	return false;
} 
\end{lstlisting}
\end{comment}

\subsection{Shortest path}

\begin{comment}
\subsubsection{BFS $\mathcal{O}(V + E)$}

\begin{lstlisting}
int n, dist[MAXN];
vector<int> edges[MAXN]; // (to, cost)

// faster than dijkstra when all edge costs are the same
int bfs(int from, int to) {
	fill_n(dist, n, -1);
	dist[from] = 0;

	queue<int> q;
	q.push(from);
	while (!q.empty()) {
		int cur = q.front();
		q.pop();
		for (int nxt : edges[cur]) {
			if (dist[nxt] >= 0) {
				dist[nxt] = dist[cur] + 1;
				if (nxt == to) return dist[nxt];
				q.push(nxt);
			}
		}
	}
	return -1;
}
\end{lstlisting}
\end{comment}

% Hier zitten sowieso al heel veel fouten in, en het is niet flexibel voor begin-, en eindpunt
\begin{comment}
\subsubsection{Dijkstra $\mathcal{O}(E + V \log V)$}

\begin{lstlisting}
int n, dist[MAXN];
bool vis[MAXN];
vector<pii> edges[MAXN]; // (to, cost)

void dijkstra() {
	fill_n(vis, n, false);
	priority_queue<pii, vector<pii>, greater<pii> > q; // (dist, vertex)
	q.push(pii(0, 0));

	while (!q.empty()) {
		pii v = q.top();
		q.pop();

		if (vis[v.y]) continue;
		vis[v.y] = true;

		for (const pii e : edges[v.y]) {
			q.push(pii(v.x + e.y, e.x));
		}
		dist[v.y] = v.x;
	}
}
\end{lstlisting}
\end{comment}

\subsubsection{Floyd-Warshall $\mathcal{O}(V^{3})$}

\begin{lstlisting}
int n = 100, d[MAXN][MAXN];
for (int i = 0; i < n; i++) fill_n(d[i], n, INF / 3);
// set direct distances from i to j in d[i][j] (and d[j][i])
for (int i = 0; i < n; i++)
	for (int j = 0; j < n; j++)
		for (int k = 0; k < n; k++)
			d[j][k] = min(d[j][k], d[j][i] + d[i][k]);
\end{lstlisting}

\subsubsection{Bellman Ford $\mathcal{O}(V E)$}

This is only useful if there are edges with weight $w_{i j} < 0$ in the graph.

\begin{lstlisting}
vector< pair<pii,int> > edges; // ((from, to), weight)
vector<int> dist(MAXN);

// when undirected, add back edges
bool bellman_ford(int source) {
	fill_n(dist, MAXN, INF / 3);
	dist[source] = 0;
	
	bool updated = true;
	int loops = 0;
	while (updated && loops < n) {
		updated = false;
		for (auto e : edges) {
			int alt = dist[e.x.x] + e.y;
			if (alt < dist[e.x.y]) {
				dist[e.x.y] = alt;
				updated = true;
			}
		}
	}
	return loops < n; // loops >= n: negative cycles
}
\end{lstlisting}

\subsection{Max-flow min-cut}
\subsubsection{Dinic's Algorithm $\mathcal{O}(V^{2} E)$}

Let's hope this algorithm works correctly! \dots

\begin{lstlisting}
// http://www.slideshare.net/KuoE0/acmicpc-dinics-algorithm
struct edge {
	int to, rev;
	ll cap, flow;
	edge(int t, int r, ll c) : to(t), rev(r), cap(c), flow(0) {}
};

int s, t, level[MAXN]; // s = source, t = sink
vector<edge> g[MAXN];

bool dinic_bfs() {
	fill_n(level, MAXN, 0);
	level[s] = 1;

	queue<int> q;
	q.push(s);
	while (!q.empty()) {
		int cur = q.front();
		q.pop();
		for (edge e : g[cur]) {
			if (level[e.to] == 0 && e.flow < e.cap) {
				level[e.to] = level[cur] + 1;
				q.push(e.to);
			}
		}
	}
	return level[t] != 0;
}

ll dinic_dfs(int cur, ll maxf) {
	if (cur == t) return maxf;

	ll f = 0;
	bool isSat = true;
	for (edge &e : g[cur]) {
		if (level[e.to] != level[cur] + 1 || e.flow >= e.cap)
			continue;
		ll df = dinic_dfs(e.to, min(maxf - f, e.cap - e.flow));
		f += df;
		e.flow += df;
		g[e.to][e.rev].flow -= df;
		isSat &= e.flow == e.cap;
		if (maxf == f) break;
	}
	if (isSat) level[cur] = 0;
	return f;
}

ll dinic_maxflow() {
	ll f = 0;
	while (dinic_bfs()) f += dinic_dfs(s, LLINF);
	return f;
}

void add_edge(int fr, int to, ll cap) {
	g[fr].push_back(edge(to, g[to].size(), cap));
	g[to].push_back(edge(fr, g[fr].size() - 1, 0));
}
\end{lstlisting}

\subsection{Min-cost max-flow}

Find the cheapest possible way of sending a certain amount of flow through a flow network.

\begin{lstlisting}
struct edge {
	// to, rev, flow, capacity, weight
	int t, r;
	ll f, c, w;
	edge(int _t, int _r, ll _c, ll _w) : t(_t), r(_r), f(0), c(_c), w(_w) {}
};

int n, par[MAXN];
vector<edge> adj[MAXN];
ll dist[MAXN];

bool findPath(int s, int t)
{
	fill_n(dist, n, LLINF);
	fill_n(par, n, -1);

	priority_queue< pii, vector<pii>, greater<pii> > q;
	q.push(pii(dist[s] = 0, s));

	while (!q.empty()) {
		int d = q.top().x, v = q.top().y;
		q.pop();
		if (d > dist[v]) continue;

		for (edge e : adj[v]) {
			if (e.f < e.c && d + e.w < dist[e.t]) {
				q.push(pii(dist[e.t] = d + e.w, e.t));
				par[e.t] = e.r;
			}
		}
	}
	return dist[t] < INF;
}

pair<ll, ll> minCostMaxFlow(int s, int t)
{
	ll cost = 0, flow = 0;
	while (findPath(s, t)) {
		ll f = INF, c = 0;
		int cur = t;
		while (cur != s) {
			const edge &rev = adj[cur][par[cur]], &e = adj[rev.t][rev.r];
			f = min(f, e.c - e.f);
			cur = rev.t;
		}
		cur = t;
		while (cur != s) {
			edge &rev = adj[cur][par[cur]], &e = adj[rev.t][rev.r];
			c += e.w;
			e.f += f;
			rev.f -= f;
			cur = rev.t;
		}
		cost += f * c;
		flow += f;
	}
	return pair<ll, ll>(cost, flow);
}

inline void addEdge(int from, int to, ll cap, ll weight)
{
	adj[from].push_back(edge(to, adj[to].size(), cap, weight));
	adj[to].push_back(edge(from, adj[from].size() - 1, 0, -weight));
}
\end{lstlisting}

\subsection{Minimal Spanning Tree}

% Kruskal is shorter...
\begin{comment}
\subsubsection{Prim $\mathcal{O}((E + V) \log V)$}

\begin{lstlisting}
// minimum spanning forest actually...
vector<pii> edges[MAXN]; // or set
int dist[MAXN];
bool done[MAXN];

ll prim(int n) {
	fill_n(dist, n, INF);
	fill_n(done, n, false);
	ll ret = 0, trees = 0;
	set<pii> q; // (to MST, vertex)
	for (int i = 0; i < n; i++) {
		if (done[i]) continue;
		trees++;
		q.insert(pii(dist[i] = 0, i));
		while (!q.empty()) {
			ret += q.begin()->first;
			int cur = q.begin()->second;
			q.erase(q.begin());
			done[cur] = true;
			for (pii pr : edges[cur]) {
				if (!done[pr.x] && pr.y < dist[pr.x]) {
					q.erase(pii(dist[pr.x], pr.x));
					dist[pr.x] = pr.y;
					q.insert(pii(dist[pr.x], pr.x));
				}
			}
		}
	}
	// if (trees > 1) return -1; // forest
	return ret;
}
\end{lstlisting}
\end{comment}

\subsubsection{Kruskal $\mathcal{O}(E \log V)$}

\begin{lstlisting}
struct edge { int x, y, w; };
edge edges[MAXM];

ll kruskal(int n, int m) { // n: #vertices, m: #edges
	uf_init(n);
	sort(edges, edges + m, [] (edge a, edge b) -> bool { return a.w < b.w; });
	ll ret = 0;
	while (m--) {
		if (uf_find(edges[m].x) == uf_find(edges[m].y)) continue;
		ret += edges[m].w;
		uf_union(edges[m].x, edges[m].y);
	}
	return ret;
}
\end{lstlisting}

\section{String algorithms}
\subsection{Z-algorithm $\mathcal{O}(n)$}

\begin{lstlisting}
// z[i] = length of longest substring starting from s[i] which is also a prefix of s.
vector<int> z_function(const string &s) {
	int n = (int) s.length();
	vector<int> z(n);
	for (int i = 1, l = 0, r = 0; i < n; ++i) {
		if (i <= r)
			z[i] = min (r - i + 1, z[i - l]);
		while (i + z[i] < n && s[z[i]] == s[i + z[i]])
			++z[i];
		if (i + z[i] - 1 > r)
			l = i, r = i + z[i] - 1;
	}
	return z;
}
\end{lstlisting}

\subsection{Suffix array $\mathcal{O}(n \log^2{n})$}

This creates an array $P[0], P[1], \dots, P[n-1]$ such that the suffix $S[i \dots n]$ is the $P[i]^\textit{th}$ suffix of $S$ when lexicographically sorted.

\begin{lstlisting}
typedef pair<pii, int> tii;

const int maxlogn = 17, int maxn = 1 << maxlogn;

tii make_triple(int a, int b, int c) { return tii(pii(a, b), c); }

int p[maxlogn + 1][maxn];
tii L[maxn];

int suffixArray(string S)
{
    int N = S.size(), stp = 1, cnt = 1;
    for (int i = 0; i < N; i++) p[0][i] = S[i];
    for (; cnt < N; stp++, cnt <<= 1) {
        for (int i = 0; i < N; i++) {
            L[i] = tii(pii(p[stp-1][i], i + cnt < N ? p[stp-1][i + cnt] : -1), i);
        }
        sort(L, L + N);
        for (int i = 0; i < N; i++) {
            p[stp][L[i].y] = i > 0 && L[i].x == L[i-1].x ? p[stp][L[i-1].y] : i;
        }
    }
	return stp - 1; // result is in p[stp - 1][0 .. (N - 1)]
}
\end{lstlisting}

\subsection{Longest Common Subsequence $\mathcal{O}(n^{2})$}
\textsc{Substring}: \textit{consecutive characters}\,!!!

\begin{lstlisting}
int table[STR_SIZE][STR_SIZE]; // DP problem

int lcs(const string &w1, const string &w2) {
	int n1 = w1.size(), n2 = w2.size();
	for (int i = 0; i <= n1; i++) table[i][0] = 0;
	for (int j = 0; j <= n2; j++) table[0][j] = 0;
	
	for (int i = 1; i < n1; i++) {
		for (int j = 1; j < n2; j++) {
			table[i][j] = w1[i - 1] == w2[j - 1] ? 
				(table[i - 1][j - 1] + 1) :
				max(table[i - 1][j], table[i][j - 1]);
		}
	}
	return table[n1][n2];
}

// backtrace
string getLCS(const string &w1, const string &w2) {
	int i = w1.size(), j = w2.size();
	string ret = "";
	while (i > 0 && j > 0) {
		if (w1[i - 1] == w2[j - 1]) ret += w1[--i], j--;
		else if (table[i][j - 1] > table[i - 1][j]) j--;
		else i--;
	}
	reverse(ret.begin(), ret.end());
	return ret;
}
\end{lstlisting}

\subsection{Levenshtein Distance $\mathcal{O}(n^{2})$}

\begin{lstlisting}
int costs[MAX_SIZE][MAX_SIZE]; // DP problem

int levDist(const string &w1, const string &w2) {
	int n1 = w1.size(), n2 = w2.size();
	for (int i = 0; i <= n1; i++) costs[i][0] = i; // removal
	for (int j = 0; j <= n2; j++) costs[0][j] = j; // insertion
	for (int i = 1; i <= n1; i++) {
		for (int j = 1; j <= n2; j++) {
			costs[i][j] = min(
				min(costs[i - 1][j] + 1, costs[i][j - 1] + 1),
				costs[i - 1][j - 1] + (w1[i - 1] != w2[j - 1])
			);
		}
	}
	return costs[n1][n2];
}
\end{lstlisting}

\subsection{Knuth-Morris-Pratt algorithm $\mathcal{O}(N + M)$}

\begin{lstlisting}
int kmp_search(const string &word, const string &text) {
	int n = word.size();
	vector<int> table(n + 1, 0);
	for (int i = 1, j = 0; i < n; ) {
		if (word[i] == word[j]) table[++i] = ++j; // match
		else if (j > 0) j = table[j]; // fallback
		else i++; // no match, keep zero
	}
	int matches = 0;
	for (int i = 0, j = 0; i < text.size(); ) {
		if (text[i] == word[j]) {
			i++;
			if (++j == n) { // match at interval [i - n, i)
				matches++;
				j = table[j];
			}
		} else if (j > 0) j = table[j];
		else i++;
	}
	return matches;
}
\end{lstlisting}

\subsection{Aho-Corasick Algorithm $\mathcal{O}(N + \sum_{i=1}^{m} |S_i|)$}

All given patterns must be unique!

\begin{lstlisting}

const int MAXP = 100, MAXLEN = 200, SIGMA = 26, MAXTRIE = MAXP * MAXLEN;

int npatterns;
string patterns[MAXP], S;

int wordIdx[MAXTRIE], to[MAXTRIE][SIGMA], sLink[MAXTRIE], dLink[MAXTRIE], nnodes;

void ahoCorasick()
{
    // 1. Make a tree, 2. create sLinks and dLinks, 3. Walk through S

    fill_n(wordIdx, MAXTRIE, -1);
    for (int i = 0; i < MAXTRIE; i++) fill_n(to[i], SIGMA, 0);
    fill_n(sLink, MAXTRIE, 0);
    fill_n(dLink, MAXTRIE, 0);
    nnodes = 1;

    for (int i = 0; i < npatterns; i++) {
        int cur = 0;
        for (char c : patterns[i]) {
            int idx = c - 'a';
            if (to[cur][idx] == 0) to[cur][idx] = nnodes++;
            cur = to[cur][idx];
        }
        wordIdx[cur] = i;
    }

    queue<int> q;
    q.push(0);
    while (!q.empty()) {
        int cur = q.front(); q.pop();
        for (int c = 0; c < SIGMA; c++) {
            if (to[cur][c]) {
                int sl = sLink[to[cur][c]] = cur == 0 ? 0 : to[sLink[cur]][c];
                // if all strings have equal length, remove this:
                dLink[to[cur][c]] = wordIdx[sl] >= 0 ? sl : dLink[sl];
                q.push(to[cur][c]);
            } else to[cur][c] = to[sLink[cur]][c];
        }
    }

    for (int cur = 0, i = 0, n = S.size(); i < n; i++) {
        int idx = S[i] - 'a';
        cur = to[cur][idx];
        for (int hit = wordIdx[cur] >= 0 ? cur : dLink[cur]; hit; hit = dLink[hit]) {
            cerr << "Match for " << patterns[wordIdx[hit]] << " at " << (i + 1 - patterns[wordIdx[hit]].size()) << endl;
        }
    }
}
\end{lstlisting}

\section{Geometry}

\begin{lstlisting}
const double EPS = 1e-7;

#define x first
#define y second

typedef double NUM; // EITHER double OR long long
typedef pair<NUM, NUM> pt;

pt operator+(pt p, pt q) { return pt(p.x + q.x, p.y + q.y); }
pt operator-(pt p, pt q) { return pt(p.x - q.x, p.y - q.y); }

pt& operator+=(pt &p, pt q) { return p = p + q; }
pt& operator-=(pt &p, pt q) { return p = p - q; }

pt operator*(pt p, NUM l) { return pt(p.x * l, p.y * l); }
pt operator/(pt p, NUM l) { return pt(p.x / l, p.y / l); }

NUM operator*(pt p, pt q) { return p.x * q.x + p.y * q.y; }
NUM operator^(pt p, pt q) { return p.x * q.y - p.y * q.x; }

istream& operator>>(istream &in, pt &p) { return in >> p.x >> p.y; }
ostream& operator<<(ostream &out, pt p) { return out << '(' << p.x << ", " << p.y << ')'; }

NUM lenSq(pt p) { return p * p; }
NUM lenSq(pt p, pt q) { return lenSq(p - q); }
double len(pt p) { return hypot(p.x, p.y); } // more overflow safe
double len(pt p, pt q) { return len(p - q); }

// square distance from pt a to line bc
double distPtLineSq(pt a, pt b, pt c) {
	a -= b, c -= b;
	return (a ^ c) * (a ^ c) / (double)(c * c);
}

// square distance from pt a to segment bc
double distPtSegmentSq(pt a, pt b, pt c) {
	a -= b; c -= b;
	NUM dot = a * c, len = c * c;
	if (dot <= 0) return a * a;
	if (dot >= len) return (a - c) * (a - c);
	return a * a - dot * dot / ((double) len);
	// pt proj = b + c * dot / ((double) len);
}

bool between(NUM x, NUM a, NUM b) { return min(a, b) <= x && x <= max(a, b); }
bool collinear(pt a, pt b, pt c) { return ((a - b) ^ (a - c)) == 0; }

// point a on segment bc
bool pointOnSegment(pt a, pt b, pt c) {
	return collinear(a, b, c) && between(a.x, b.x, c.x) && between(a.y, b.y, c.y);
}

// REQUIRES DOUBLES
pt lineLineIntersection(pt a, pt b, pt c, pt d, bool &cross)
{
	NUM det = (a - b) ^ (c - d);
	pt ret = (c - d) * (a ^ b) - (a - b) * (c ^ d);
	return (cross = det != 0) ? (ret / det) : ret;
}

// REQUIRES DOUBLES
// Line segment a1 -- a2 intersects with b1 -- b2?
// returns 0: no, 1: yes at i1, 2: yes at i1 -- i2
int segmentsIntersect(pt a1, pt a2, pt b1, pt b2, pt &i1, pt &i2) {
	if (((a2 - a1) ^ (b2 - b1)) < 0) swap(a1, a2);
	// assert(a1 != a2 && b1 != b2);
	pt q = a2 - a1, r = b2 - b1, s = b1 - a1;
	NUM cross = q ^ r, c1 = s ^ r, c2 = s ^ q;
	if (cross == 0) {
		// line segments are parallel
		if ((q ^ s) != 0) return 0; // no intersection
		NUM v1 = s * q, v2 = (b2 - a1) * q, v3 = q * q;
		if (v2 < v1) swap(v1, v2), swap(b1, b2);

		if (v1 > v3 || v2 < 0) return 0; // intersection empty
		i1 = v2 > v3 ? a2 : b2;
		i2 = v1 < 0 ? a1 : b1;
		return i1 == i2 ? 1 : 2; // one point or overlapping
	} else { // cross > 0
		i1 = pt(a1) + pt(q) * (1.0 * c1 / cross); // needs double
		return 0 <= c1 && c1 <= cross && 0 <= c2 && c2 <= cross;
		// intersection inside segments
	}
}

// REQUIRES DOUBLES
// TODO: Needs shortening
// complete intersection check
int segmentsIntersect2(pt a1, pt a2, pt b1, pt b2, pt &i1, pt &i2) {
	if (a1 == a2 && b1 == b2) {
		i1 = a1;
		return a1 == b1;
	} else if (a1 == a2) {
		i1 = a1;
		return pointOnSegment(a1, b1, b2);
	} else if (b1 == b2) {
		i1 = b1;
		return pointOnSegment(b1, a1, a2);
	} else return segmentsIntersect(a1, a2, b1, b2, i1, i2);
}

// Returns TWICE the area of a polygon to keep it an integer
NUM polygonTwiceArea(const vector<pt> &pts) {
	NUM area = 0;
	for (int N = pts.size(), i = 0, j = N - 1; i < N; j = i++)
		area += pts[i] ^ pts[j];
	return abs(area); // area < 0 <=> pts ccw
}

bool pointInPolygon(pt p, const vector<pt> &pts)
{
    double sum = 0;
    for (int N = pts.size(), i = 0, j = N - 1; i < N; j = i++) {
		if (pointOnSegment(p, pts[i], pts[j])) return true; // boundary
		double angle = acos((pts[i] - p) * (pts[j] - p) / len(pts[i], p) / len(pts[j], p));
        sum += ((pts[i] - p) ^ (pts[j] - p)) < 0 ? angle : -angle;
    }
    return abs(abs(sum) - 2 * PI) < EPS;
}
\end{lstlisting}

\begin{comment}
// Assumption: polygon has unique points
// 0: no, 1: yes, 2: on boundary
int pointInConvex(pt p, const vector<pt> &pts) {
bool onBoundary = false;
for (int N = pts.size(), sgn = 0, i = 0, j = N - 1; i < N; j = i++) {
NUM cross = (pts[i] - p) ^ (pts[j] - p);
int s = (cross > 0) - (cross < 0);
if (cross == 0) onBoundary = true;
else if (sgn == 0) sgn = s;
else if (sgn != s) return 0;
}
return onBoundary ? 2 : 1;
}
\end{comment}

\subsection{Convex Hull $\mathcal{O}(n \log n)$}

\begin{lstlisting}
// points are given by: pts[ret[0]], pts[ret[1]], ... pts[ret[ret.size()-1]]
vector<int> convexHull(const vector<pt> &pts) {
	if (pts.empty()) return vector<int>();
	vector<int> ret;
	int bestIndex = 0, n = pts.size();
	pt best = pts[0];
	for(int i = n; i--; ) {
		if (pts[i] < best) {
			best = pts[bestIndex = i];
		}
	}
	ret.push_back(bestIndex);
	pt refr = pts[bestIndex];

	vector<int> ordered; // index into pts
	for (int i = n; i--; ) {
		if (pts[i] != refr) ordered.push_back(i);
	}
	sort(ordered.begin(), ordered.end(), [&pts, &refr] (int a, int b) -> bool {
		NUM cross = (pts[a] - refr) ^ (pts[b] - refr);
		return cross != 0 ? cross > 0 : lenSq(refr, pts[a]) < lenSq(refr, pts[b]);
	});
	for (int i : ordered) {
		// NOTE: > INCLUDES points on the hull-line, >= EXCLUDES
		while (ret.size() > 1 && ((pts[ret[ret.size() - 2]] - pts[ret.back()]) ^ (pts[i] - pts[ret.back()])) >= 0) {
			ret.pop_back();
		}
		ret.push_back(i);
	}
	return ret;
}
\end{lstlisting}

\subsection{Rotating Calipers $\mathcal{O}(n)$}

Finds the longest distance between two points in a convex hull.

\begin{lstlisting}
NUM rotatingCalipers(vector<pt> &hull) {
    int n = hull.size(), a = 0, b = 1;
    if (n <= 1) return 0.0;
    while (((hull[1] - hull[0]) ^ (hull[(b + 1) % n] - hull[b])) > 0) b++;
    cerr << a << " " << b << endl;
    NUM ret = 0.0;
    while (a < n) {
        ret = max(ret, lenSq(hull[a], hull[b]));
        if (((hull[(a + 1) % n] - hull[a % n]) ^ (hull[(b + 1) % n] - hull[b])) <= 0) a++;
        else if (++b == n) b = 0;
    }
    return ret;
}
\end{lstlisting}

\section{Miscellaneous}
\subsection{Binary search $\mathcal{O}(\log (hi - lo))$}

% \noindent\begin{minipage}{.45\textwidth}
% [title={Inclusive, Exclusive}]
\begin{lstlisting}
bool test(int n);

int search(int lo, int hi) {
	// assert(test(lo) && !test(hi));
	while (hi - lo > 1) {
		int c = (lo + hi) / 2;
		if (test(c)) lo = c;
		else         hi = c;
	}
	// assert(test(lo) && !test(hi));
	return lo;
}
\end{lstlisting}

\begin{comment}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
	\begin{lstlisting}[title={Inclusive, Inclusive}]
bool test(int n);
	
int lo = 0, hi = n - 1;
// assert(test(lo) && !test(hi + 1));
while (lo < hi) {
	int mid = (lo + hi + 1) / 2;
	if (test(mid)) lo = mid;
	else hi = mid - 1;
}
return lo;
	\end{lstlisting}
\end{minipage}
\end{comment}

\subsection{Fast Fourier Transform $\mathcal{O}(n \log n)$}

Given two polynomials $A(x) = a_0 + a_1 x + \dots + a_{n/2} x^{n/2}$ and $B(x) = b_0 + b_1 x + \dots + b_{n/2} x^{n/2}$, FFT calculates all coefficients of $C(x) = A(x) \cdot B(x) = c_0 + c_1 x + \dots c_{n} x^{n}$, with $c_i = \sum_{j=0}^{i} a_j b_{i-j}$.

\begin{lstlisting}

typedef complex<double> cpx;
const int logmaxn = 20, maxn = 1 << logmaxn;

cpx a[maxn] = {}, b[maxn] = {}, c[maxn];

void fft(cpx *src, cpx *dest)
{
	for (int i = 0, rep = 0; i < maxn; i++, rep = 0) {
		for (int j = i, k = logmaxn; k--; j >>= 1) rep = (rep << 1) | (j & 1);
		dest[rep] = src[i];
	}
	for (int s = 1, m = 1; m <= maxn; s++, m *= 2) {
		cpx r = exp(cpx(0, 2.0 * PI / m));
		for (int k = 0; k < maxn; k += m) {
			cpx cr(1.0, 0.0);
			for (int j = 0; j < m / 2; j++) {
				NUM t = cr * dest[k + j + m / 2];
				dest[k + j + m / 2] = dest[k + j] - t;
				dest[k + j] += t;
				cr *= r;
			}
		}
	}
}

void multiply()
{
	fft(a, c);
	fft(b, a);
	for (int i = 0; i < maxn; i++) b[i] = conj(a[i] * c[i]);
	fft(b, c);
	for (int i = 0; i < maxn; i++) c[i] = conj(c[i]) / (1.0 * maxn);
}
\end{lstlisting}

\subsection{Minimum Assignment (Hungarian Algorithm) $\mathcal{O}(n^{3})$}

\begin{lstlisting}
int a[MAXN + 1][MAXM + 1]; // matrix, 1-based

int minimum_assignment(int n, int m) { // n rows, m columns
	vector<int> u(n + 1), v(m + 1), p(m + 1), way(m + 1);

	for (int i = 1; i <= n; i++) {
		p[0] = i;
		int j0 = 0;
		vector<int> minv(m + 1, INF);
		vector<char> used(m + 1, false);
		do {
			used[j0] = true;
			int i0 = p[j0], delta = INF, j1;
			for (int j = 1; j <= m; j++)
				if (!used[j]) {
					int cur = a[i0][j] - u[i0] - v[j];
					if (cur < minv[j]) minv[j] = cur, way[j] = j0;
					if (minv[j] < delta) delta = minv[j], j1 = j;
				}
			for (int j = 0; j <= m; j++) {
				if(used[j]) u[p[j]] += delta, v[j] -= delta;
				else minv[j] -= delta;
			}
			j0 = j1;
		} while (p[j0] != 0);
		do {
			int j1 = way[j0];
			p[j0] = p[j1];
			j0 = j1;
		} while (j0);
	}

	// column j is assigned to row p[j]
	// for (int j = 1; j <= m; ++ j) ans[p[j]] = j;
	return -v[0];
}
\end{lstlisting}

\end{document}

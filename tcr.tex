
\documentclass[8pt,a4paper,landscape,oneside]{amsart}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{color}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{fullpage}
\usepackage{xcolor}
\usepackage{textcomp}
%\usepackage{geometry}
% \usepackage[top=0pt, bottom=1cm, left=0.3cm, right=0.3cm]{geometry}
\usepackage[top=10pt, bottom=5pt, left=0.3cm, right=0.3cm,, headsep=0pt, headheight=3cm,landscape]{geometry}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{titling}
\usepackage{datetime}
\usepackage{enumitem}
\usepackage{color,courier,fancyhdr,listings,parcolumns,verbatim,upquote}
\usepackage{multicol}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{latexsym}
\usepackage{fancyhdr}
\usepackage{wrapfig}

\usepackage{minted}
\newcommand{\code}[1]{\inputminted[fontsize=\normalsize,baselinestretch=1,breaklines,linenos,tabsize=2]{cpp}{code/#1}}
%\newcommand{\code}[1]{\lstinputlisting{code/#1}}
\newcommand{\bashcode}[1]{\inputminted{bash}{_code/#1}}
\newcommand{\regcode}[1]{\inputminted{cpp}{code/#1}}
%\usemintedstyle{manni}

\pagestyle{fancy}

\newcommand{\subtitle}[1]{%
  \posttitle{%
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.1em\vspace{-1em}}%
}

% Header/Footer
% \geometry{includeheadfoot}
%\fancyhf{}
%\pagestyle{fancy}
\begin{comment}
\lhead{Utrecht University}
\rhead{\thepage}
\cfoot{}
\setlength{\headheight}{15.2pt}
\setlength{\droptitle}{-20pt}
\posttitle{\par\end{center}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\end{comment}
% Math and bit operators
\DeclareMathOperator{\lcm}{lcm}
\newcommand*\BitAnd{\mathrel{\&}}
\newcommand*\BitOr{\mathrel{|}}
\newcommand*\ShiftLeft{\ll}
\newcommand*\ShiftRight{\gg}
\newcommand*\BitNeg{\ensuremath{\mathord{\sim}}}
\DeclareRobustCommand{\stirling}{\genfrac\{\}{0pt}{}}

\newenvironment{myitemize}
{ \begin{itemize}[leftmargin=.5cm]
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}     }
{ \end{itemize}                  }

% Output Verbosity
\newif\ifverbose
\verbosetrue
% \verbosefalse

\title{TCR}
\subtitle{git diff solution (Jens Heuseveldt, Ludo Pulles, Pim Spelier)}

\lstset{showstringspaces=false,
  literate={~} {$\sim$}{1},
	basicstyle=\footnotesize\ttfamily,
	breaklines=true,
	commentstyle=\color[rgb]{0.5,0.5,0.5},
	frame=lines,
	keywordstyle=\color{blue},
	language=C++,
	numbers=left,
	numbersep=5pt,
	numberstyle=\tiny\color[rgb]{0.6,0.6,0.6},
	otherkeywords={cin, cout, cerr, pii, pll, PI, INF, LLINF, NUM},
	showstringspaces=false,
	stringstyle=\color[rgb]{0.6,0.3,0},
	tabsize=4,
	xleftmargin=\parindent,
	columns=[l]fixed,
	keepspaces=true,
	tabsize=4,
	language=C++,
	numbers=left,
	numberstyle=\tiny,
	stepnumber=1,
	frame=leftline,
	basicstyle=\small\ttfamily,
	keywordstyle=\color{Maroon},
	commentstyle=\color{MidnightBlue}
}

\lhead{Utrecht University}
\rhead{git diff solution}

\usepackage[scaled]{beramono}
\begin{document}

\begin{multicols*}{3}
\maketitle
\begin{comment}
\begin{center}
	\makeatletter
	\textbf{\@title} \\
%	\today \\
	\emph{\@author}
	\makeatother
\end{center}
\end{comment}

\tableofcontents
% \newpage

\begin{center}
At the start of a contest, type this in a terminal:
\end{center}

\lstinputlisting{code/start.sh}

\begin{center}
template.cpp
\end{center}

\code{T.cpp}

Prime numbers: $\mathit{982451653}$, $\mathit{81253449}$, $10^3 + \{-9,-3,9,13\}$, $10^6 + \{-17, 3, 33\}$, $10^9 + \{7,9,21,33,87\}$

\subsection{De winnende aanpak}

\begin{itemize}
	\setlength\itemsep{-.25em}
	\item Goed slapen \& een vroeg ritme hebben
	\item Genoeg drinken \& eten voor en tijdens de wedstrijd
	\item Een lijst van alle problemen met info waar het over gaat, en wie het goed kan oplossen
	\item Ludo moet {\huge\textbf{ALLE}} opgaves \textbf{goed} lezen
	\item Test de kleine voorbeeldgevallen
	\item Houd na 2 uur een pauze en overleg waar iedereen mee bezig is
	\item Maak zelf wat test-cases
	\item Typ de dingen uit de TCR, die je zeker nodig hebt, alvast in
	\item Als iemand niks te doen heeft, kan hij nodige dingen uit de TCR typen.
	\item We moeten ook een voorbeeld test-case voor TCR algoritmes hebben om te testen of het goed overgetypt is
	\item Bij geometrie moeten we om kunnen gaan met meerdere input manieren (voor bv. lijnen)
	\item Gebruik veel long long\textquotesingle s
\end{itemize}

\subsection{Wrong Answer}

\begin{enumerate}
	\setlength\itemsep{-.25em}
	\item Print de oplossing om te debuggen! Kijk ook naar andere (mogelijk makkelijkere) problemen.
	\item Bedenk zelf test-cases met \textbf{randgevallen}!
	\item Controleer op \textbf{overflow} (gebruik \textbf{OVERAL} long long, long double).
		\\ \textit{Kijk naar overflows in tussenantwoorden bij modulo.}
	\item Controleer de \textbf{precisie}.
	\item Controleer op \textbf{typo\textquotesingle s}.
	\item Loop de voorbeeldinput accuraat langs.
	\item Controller op off-by-one-errors (in indices of lus-grenzen)?
\end{enumerate}

\subsection{Detecting overflow}
These are GNU builtins, detect both over- and underflow. Returns a boolean upon failure, otherwise the result is present in \texttt{ref}. Follow the template:

\begin{lstlisting}
bool isOverflown = __builtin_[add|mul|sub]_overflow(a, b, \&res);
\end{lstlisting}

\subsection{Covering problems}

\begin{center}
	\emph{Minimum edge cover$\iff$Maximum independent set}
\end{center}

\begin{description}
	\setlength\itemsep{-.25em}
	\item[Matching]
		A set of edges without common vertices \textit{(Maximum is the \textbf{largest} such set, maximal is a set which you cannot add more edges to without breaking the property)}.
	\item[Minimum Vertex Cover]
		A set vertices (cover) such that each edge in the graph is incident to at least one vertex of the set.
	\item[Minimum Edge Cover]
		A set of edges (cover) such that every vertex is incident to at least one edge of the set.
	\item[Maximum Independent Set]
		A set of vertices in a graph such that no two of them are adjacent.
	\item[K\"{o}nig's theorem]
		In any bipartite graph, the number of edges in a maximum matching equals the number of vertices in a minimum vertex cover
\end{description}

% \begin{comment}
\subsection{Game theory}

A game can be reduced to Nim if it is a finite impartial game. Nim and its variants include:
\begin{description}
	\item[Nim] Let $X = \bigoplus_{i=1}^n x_i$, then $(x_i)_{i=1}^n$ is a winning position iff $X\neq 0$. Find a move by picking $k$ such that $x_k > x_k \oplus X$.
	\item[Mis\`{e}re Nim] Regular Nim, except that the last player to move \textit{loses}. Play regular Nim until there is only one pile of size larger than $1$, reduce it to $0$ or $1$ such that there is an odd number of piles.
	\item[Staricase Nim] Stones are moved down a staircase and only removed from the last pile. $(x_i)_{i=1}^n$ is an $L$-position if $(x_{2i-1})_{i=1}^{n/2}$ is (i.e. only look at odd-numbered piles).
	\item[Moore's Nim$_k$] The player may remove from at most $k$ piles (Nim $=$ Nim$_1$). Expand the piles in base $2$, do a carry-less addition in base $k+1$ (i.e. the number of ones in each column should be divisible by $k+1$).
	\item[Dim$^+$] The number of removed stones must be a divisor of the pile size. The Sprague-Grundy function is $k+1$ where $2^k$ is the largest power of $2$ dividing the pile size.
	\item[Aliquot game] Same as above, except the divisor should be proper (hence $1$ is also a terminal state, but watch out for size $0$ piles). Now the Sprague-Grundy function is just $k$.
	\item[Nim (at most half)] Write $n+1 = 2^my$ with $m$ maximal, then the Sprague-Grundy function of $n$ is $(y - 1) / 2$.
	\item[Lasker's Nim] Players may alternatively split a pile into two new non-empty piles. $g(4k+1) = 4k+1$, $g(4k+2) = 4k+2$, $g(4k+3) = 4k+4$, $g(4k+4) = 4k+3$ ($k\geq 0$).
	\item[Hackenbush on trees] A tree with stalks $(x_i)_{i=1}^n$ may be replaced with a single stalk with length $\bigoplus_{i=1}^n x_i$.
\end{description}
% \end{comment}

A useful identity: $\bigoplus_{x=0}^{a - 1} x = \{0, a - 1, 1, a\}[a \, \mathrm{mod} \, 4]$.

\section{Mathematics}

\code{math.cpp}

\section{Datastructures}
\subsection{Standard segment tree $\mathcal{O}(\log n)$}

\code{datastructures/segment_tree.cpp}

\subsection{Binary Indexed Tree $\mathcal{O}(\log n)$}

Use one-based indices ($i > 0$)!

\code{datastructures/bit.cpp}

\subsection{Disjoint-Set / Union-Find $\mathcal{O}(\alpha (n))$}

\code{datastructures/dsu.cpp}

\section{Graph Algorithms}
% TODO: articulation points, and bridges!
\subsection{Maximum matching $\mathcal{O}(n m)$}

This problem could be solved with a flow algorithm like Dinic's algorithm which runs in $\mathcal{O} (\sqrt{V} E)$, too.

\code{graphs/maxmatch.cpp}

\subsection{Strongly Connected Components $\mathcal{O}(V + E)$}

\code{graphs/scc.cpp}

\subsubsection{2-SAT $\mathcal{O}(V+E)$}

Include \texttt{findSCC}.

\code{satsolver.cpp}

% \begin{comment}
\subsection{Cycle Detection $\mathcal{O}(V + E)$}

\code{findcycle.cpp}
% \end{comment}

\subsection{Shortest path}

% Hier zitten sowieso al heel veel fouten in, en het is niet flexibel voor begin-, en eindpunt
\subsubsection{Dijkstra $\mathcal{O}(E + V \log V)$}

\subsubsection{Floyd-Warshall $\mathcal{O}(V^{3})$}

\code{graphs/floydwarshall.cpp}

\subsubsection{Bellman Ford $\mathcal{O}(V E)$}

This is only useful if there are edges with weight $w_{i j} < 0$ in the graph.

\code{graphs/bellmanford.cpp}

\subsection{Max-flow min-cut}
\subsubsection{Dinic's Algorithm $\mathcal{O}(V^{2} E)$}

\begin{comment}
// http://www.slideshare.net/KuoE0/acmicpc-dinics-algorithm
\end{comment}

\code{graphs/dinic.cpp}

\subsection{Min-cost max-flow}

Find the cheapest possible way of sending a certain amount of flow through a flow network.

\code{graphs/mincostmaxflow.cpp}

\subsection{Minimal Spanning Tree}

% Kruskal is shorter...
\begin{comment}
\subsubsection{Prim $\mathcal{O}((E + V) \log V)$}

\code{graphs/mst_prim.cpp}
\end{comment}

\subsubsection{Kruskal $\mathcal{O}(E \log V)$}

\begin{comment}
\code{graphs/mst_kruskal.cpp}
\end{comment}

\section{String algorithms}

\subsection{Trie}

\code{strings/trie.cpp}

\subsection{Z-algorithm $\mathcal{O}(n)$}

\code{strings/z_function.cpp}

\subsection{Suffix array $\mathcal{O}(n \log^2{n})$}

This creates an array $P[0], P[1], \dots, P[n-1]$ such that the suffix $S[i \dots n]$ is the $P[i]^\textit{th}$ suffix of $S$ when lexicographically sorted.

\code{strings/suffixarray.cpp}

\subsection{Longest Common Subsequence $\mathcal{O}(n^{2})$}
\textsc{Substring}: \textit{consecutive characters}\,!!!

\code{strings/lcs.cpp}

\subsection{Levenshtein Distance $\mathcal{O}(n^{2})$}

Also known as the `Edit distance'.

\code{strings/edit_dist.cpp}

\subsection{Knuth-Morris-Pratt algorithm $\mathcal{O}(N + M)$}

\code{strings/kmp.cpp}

\subsection{Aho-Corasick Algorithm $\mathcal{O}(N + \sum_{i=1}^{m} |S_i|)$}

All given P must be unique!

\code{strings/aho_corasick.cpp}

\section{Geometry}

\code{geometry/main.cpp}

\subsection{Convex Hull $\mathcal{O}(n \log n)$}

\code{geometry/convex_hull.cpp}

\subsection{Rotating Calipers $\mathcal{O}(n)$}

Finds the longest distance between two points in a convex hull.

\code{geometry/rotating_calipers.cpp}

\subsection{Closest points $\mathcal{O}(n \log n)$}

\code{geometry/closest_points.cpp}

\section{Miscellaneous}
\subsection{Binary search $\mathcal{O}(\log (hi - lo))$}

\code{binary_search.cpp}

\subsection{Fast Fourier Transform $\mathcal{O}(n \log n)$}

Given two polynomials $A(x) = a_0 + a_1 x + \dots + a_{n/2} x^{n/2}$ and $B(x) = b_0 + b_1 x + \dots + b_{n/2} x^{n/2}$, FFT calculates all coefficients of $C(x) = A(x) \cdot B(x) = c_0 + c_1 x + \dots c_{n} x^{n}$, with $c_i = \sum_{j=0}^{i} a_j b_{i-j}$.

\code{fft.cpp}

\subsection{Minimum Assignment (Hungarian Algorithm) $\mathcal{O}(n^{3})$}

\code{minimum_assignment.cpp}

\subsection{Partial linear equation solver $\mathcal{O}(N^3)$}

\code{matrix_solver.cpp}
\end{multicols*}
\onecolumn
\begin{multicols*}{3}
\section{Useful Information}

    \section{Misc}
        \subsection{Debugging Tips}
            \begin{myitemize}
                \item Stack overflow? Recursive DFS on tree that is actually a long path?
                \item Floating-point numbers
                    \begin{itemize}
                        \item Getting \texttt{NaN}? Make sure \texttt{acos} etc.\ are
                            not getting values out of their range (perhaps
                            \texttt{1+eps}).
                        \item Rounding negative numbers?
                        \item Outputting in scientific notation?
                    \end{itemize}
                \item Wrong Answer?
                    \begin{itemize}
                        \item Read the problem statement again!
                        \item Are multiple test cases being handled correctly?
                              Try repeating the same test case many times.
                        \item Integer overflow?
                        \item Think very carefully about boundaries of all input parameters
                        \item Try out possible edge cases:
                            \begin{itemize}
                                \item $n=0, n=-1, n=1, n=2^{31}-1$ or $n=-2^{31}$
                                \item List is empty, or contains a single element
                                \item $n$ is even, $n$ is odd
                                \item Graph is empty, or contains a single vertex
                                \item Graph is a multigraph (loops or multiple edges)
                                \item Polygon is concave or non-simple
                            \end{itemize}
                        \item Is initial condition wrong for small cases?
                        \item Are you sure the algorithm is correct?
                        \item Explain your solution to someone.
                        \item Are you using any functions that you don't completely understand? Maybe STL functions?
                        \item Maybe you (or someone else) should rewrite the solution?
                        \item Can the input line be empty?
                    \end{itemize}
                \item Run-Time Error?
                    \begin{itemize}
                        \item Is it actually Memory Limit Exceeded?
                    \end{itemize}
            \end{myitemize}

        \subsection{Solution Ideas}
            \begin{myitemize}
                \item Dynamic Programming
                    \begin{itemize}
                        \item Parsing CFGs: CYK Algorithm
                        \item Drop a parameter, recover from others
                        \item Swap answer and a parameter
                        \item When grouping: try splitting in two
                        \item $2^k$ trick
                        \item When optimizing
                            \begin{itemize}
                                \item Convex hull optimization
                                    \begin{itemize}
                                        \item $\mathrm{dp}[i] = \min_{j<i}\{\mathrm{dp}[j] + b[j] \times a[i]\}$
                                        \item $b[j] \geq b[j+1]$
                                        \item optionally $a[i] \leq a[i+1]$
                                        \item $O(n^2)$ to $O(n)$
                                    \end{itemize}
                                \item Divide and conquer optimization
                                    \begin{itemize}
                                        \item $\mathrm{dp}[i][j] = \min_{k<j}\{\mathrm{dp}[i-1][k] + C[k][j]\}$
                                        \item $A[i][j] \leq A[i][j+1]$
                                        \item $O(kn^2)$ to $O(kn\log{n})$
                                        \item sufficient: $C[a][c] + C[b][d] \leq C[a][d] + C[b][c]$, $a\leq b\leq c\leq d$ (QI)
                                    \end{itemize}
                                \item Knuth optimization
                                    \begin{itemize}
                                        \item $\mathrm{dp}[i][j] = \min_{i<k<j}\{\mathrm{dp}[i][k] + \mathrm{dp}[k][j] + C[i][j]\}$
                                        \item $A[i][j-1] \leq A[i][j] \leq A[i+1][j]$
                                        \item $O(n^3)$ to $O(n^2)$
                                        \item sufficient: QI and $C[b][c] \leq C[a][d]$, $a\leq b\leq c\leq d$
                                    \end{itemize}
                            \end{itemize}
                    \end{itemize}
                \item Greedy
                \item Randomized
                \item Optimizations
                    \begin{itemize}
                        \item Use bitset (/64)
                        \item Switch order of loops (cache locality)
                    \end{itemize}
                \item Process queries offline
                    \begin{itemize}
                        \item Mo's algorithm
                    \end{itemize}
                \item Square-root decomposition
                \item Precomputation
                \item Efficient simulation
                    \begin{itemize}
                        \item Mo's algorithm
                        \item Sqrt decomposition
                        \item Store $2^k$ jump pointers
                    \end{itemize}
                \item Data structure techniques
                    \begin{itemize}
                        \item Sqrt buckets
                        \item Store $2^k$ jump pointers
                        \item $2^k$ merging trick
                    \end{itemize}
                \item Counting
                    \begin{itemize}
                        \item Inclusion-exclusion principle
                        \item Generating functions
                    \end{itemize}
                \item Graphs
                    \begin{itemize}
                        \item Can we model the problem as a graph?
                        \item Can we use any properties of the graph?
                        \item Strongly connected components
                        \item Cycles (or odd cycles)
                        \item Bipartite (no odd cycles)
                            \begin{itemize}
                                \item Bipartite matching
                                \item Hall's marriage theorem
                                \item Stable Marriage
                            \end{itemize}
                        \item Cut vertex/bridge
                        \item Biconnected components
                        \item Degrees of vertices (odd/even)
                        \item Trees
                            \begin{itemize}
                                \item Heavy-light decomposition
                                \item Centroid decomposition
                                \item Least common ancestor
                                \item Centers of the tree
                            \end{itemize}
                        \item Eulerian path/circuit
                        \item Chinese postman problem
                        \item Topological sort
                        \item (Min-Cost) Max Flow
                        \item Min Cut
                            \begin{itemize}
                                \item Maximum Density Subgraph
                            \end{itemize}
                        \item Huffman Coding
                        \item Min-Cost Arborescence
                        \item Steiner Tree
                        \item Kirchoff's matrix tree theorem
                        \item Pr\"ufer sequences
                        \item Lov\'asz Toggle
                        \item Look at the DFS tree (which has no cross-edges)
                        \item Is the graph a DFA or NFA?
                            \begin{itemize}
                                \item Is it the Synchronizing word problem?
                            \end{itemize}
                    \end{itemize}
                \item Mathematics
                    \begin{itemize}
                        \item Is the function multiplicative?
                        \item Look for a pattern
                        \item Permutations
                            \begin{itemize}
                                \item Consider the cycles of the permutation
                            \end{itemize}
                        \item Functions
                            \begin{itemize}
                                \item Sum of piecewise-linear functions is a piecewise-linear function
                                \item Sum of convex (concave) functions is convex (concave)
                            \end{itemize}
                        \item Modular arithmetic
                            \begin{itemize}
                                \item Chinese Remainder Theorem
                                \item Linear Congruence
                            \end{itemize}
                        \item Sieve
                        \item System of linear equations
                        \item Values too big to represent?
                            \begin{itemize}
                                \item Compute using the logarithm
                                \item Divide everything by some large value
                            \end{itemize}
                        \item Linear programming
                            \begin{itemize}
                                \item Is the dual problem easier to solve?
                            \end{itemize}
                        \item Can the problem be modeled as a different combinatorial problem? Does that simplify calculations?
                    \end{itemize}
                \item Logic
                    \begin{itemize}
                        \item 2-SAT
                        \item XOR-SAT (Gauss elimination or Bipartite matching)
                    \end{itemize}
                \item Meet in the middle
                \item Only work with the smaller half ($\log(n)$)
                \item Strings
                    \begin{itemize}
                        \item Trie (maybe over something weird, like bits)
                        \item Suffix array
                        \item Suffix automaton (+DP?)
                        \item Aho-Corasick
                        \item eerTree
                        \item Work with $S+S$
                    \end{itemize}
                \item Hashing
                \item Euler tour, tree to array
                \item Segment trees
                    \begin{itemize}
                        \item Lazy propagation
                        \item Persistent
                        \item Implicit
                        \item Segment tree of X
                    \end{itemize}
                \item Geometry
                    \begin{itemize}
                        \item Minkowski sum (of convex sets)
                        \item Rotating calipers
                        \item Sweep line (horizontally or vertically?)
                        \item Sweep angle
                        \item Convex hull
                    \end{itemize}
                \item Fix a parameter (possibly the answer).
                \item Are there few distinct values?
                \item Binary search
                \item Sliding Window (+ Monotonic Queue)
                \item Computing a Convolution? Fast Fourier Transform
                \item Computing a 2D Convolution? FFT on each row, and then on each column
                \item Exact Cover (+ Algorithm X)
                \item Cycle-Finding
                \item What is the smallest set of values that identify the solution? The cycle structure of the permutation? The powers of primes in the factorization?
                \item Look at the complement problem
                    \begin{itemize}
                        \item Minimize something instead of maximizing
                    \end{itemize}
                \item Immediately enforce necessary conditions. (All values greater than 0? Initialize them all to 1)
                \item Add large constant to negative numbers to make them positive
                \item Counting/Bucket sort
            \end{myitemize}

    \section{Formulas}

        % \item Number of permutations of length $n$ that have no fixed
        %     points (derangements): $D_0 = 1, D_1 = 0, D_n = (n - 1)(D_{n-1}
        %     + D_{n-2})$
        % \item Number of permutations of length $n$ that have exactly $k$
        %     fixed points: $\binom{n}{k} D_{n-k}$


        \begin{itemize}[leftmargin=*]
            \item \textbf{Legendre symbol:} $\left(\frac{a}{b}\right) = a^{(b-1)/2} \pmod{b}$, $b$ odd prime.
            \item \textbf{Heron's formula:} A triangle with side lengths
                $a,b,c$ has area $\sqrt{s(s-a)(s-b)(s-c)}$ where $s =
                \frac{a+b+c}{2}$.
            \item \textbf{Pick's theorem:} A polygon on an integer grid
                strictly containing $i$ lattice points and having $b$ lattice
                points on the boundary has area $i + \frac{b}{2} - 1$. (Nothing
                similar in higher dimensions)
            \item \textbf{Euler's totient:} The number of integers less than
                $n$ that are coprime to $n$ are $n\prod_{p|n}\left(1 - \frac{1}{p}\right)$
                where each $p$ is a distinct prime factor of $n$.
            \item \textbf{König's theorem:} In any bipartite graph $G=(L\cup R,E)$, the number
                of edges in a maximum matching is equal to the number of
                vertices in a minimum vertex cover. Let $U$ be the set of
                unmatched vertices in $L$, and $Z$ be the set of vertices that
                are either in $U$ or are connected to $U$ by an alternating
                path. Then $K=(L\setminus Z)\cup(R\cap Z)$ is the minimum
                vertex cover.
            \item A minumum Steiner tree for $n$ vertices requires at most $n-2$ additional Steiner vertices.
            \item The number of vertices of a graph is equal to its minimum
                vertex cover number plus the size of a maximum independent set.
            \item \textbf{Lagrange polynomial} through points $(x_0,y_0),\ldots,(x_k,y_k)$ is $L(x) = \sum_{j=0}^k y_j \prod_{\shortstack{$\scriptscriptstyle 0\leq m \leq k$ \\ $\scriptscriptstyle m\neq j$}} \frac{x-x_m}{x_j - x_m}$
            \item \textbf{Hook length formula:} If $\lambda$ is a Young diagram and $h_{\lambda}(i,j)$ is the hook-length of cell $(i,j)$, then then the number of Young tableux $d_{\lambda} = n!/\prod h_{\lambda}(i,j)$.
            \item \textbf{Möbius inversion formula:} If $f(n) = \sum_{d|n} g(d)$, then $g(n) = \sum_{d|n} \mu(d) f(n/d)$. If $f(n) = \sum_{m=1}^n g(\lfloor n/m\rfloor)$, then $g(n) = \sum_{m=1}^n \mu(m)f(\lfloor\frac{n}{m}\rfloor)$.
            \item \#primitive pythagorean triples with hypotenuse $<n$ approx $n/(2\pi)$.
            \item \textbf{Frobenius Number:} largest number which can't be
                expressed as a linear combination of numbers $a_1,\ldots,a_n$
                with non-negative coefficients. $g(a_1,a_2) = a_1a_2-a_1-a_2$,
                $N(a_1,a_2)=(a_1-1)(a_2-1)/2$. $g(d\cdot a_1,d\cdot a_2,a_3) =
                d\cdot g(a_1,a_2,a_3) + a_3(d-1)$. An integer $x>\left(\max_i
                a_i\right)^2$ can be expressed in such a way iff.\ $x\ |\
                \mathrm{gcd}(a_1,\ldots,a_n)$.
        \end{itemize}

        \subsection{Physics}
            \begin{itemize}
                \item \textbf{Snell's law:} $\frac{\sin\theta_1}{v_1} = \frac{\sin\theta_2}{v_2}$
            \end{itemize}

        \subsection{Markov Chains}
            A Markov Chain can be represented as a weighted directed graph of
            states, where the weight of an edge represents the probability of
            transitioning over that edge in one timestep. Let $P^{(m)} = (p^{(m)}_{ij})$
            be the probability matrix of transitioning from state $i$ to state $j$
            in $m$ timesteps, and note that $P^{(1)}$ is the adjacency matrix of
            the graph. \textbf{Chapman-Kolmogorov:} $p^{(m+n)}_{ij} = \sum_{k}
            p^{(m)}_{ik} p^{(n)}_{kj}$. It follows that $P^{(m+n)} =
            P^{(m)}P^{(n)}$ and $P^{(m)} = P^m$. If $p^{(0)}$ is the initial
            probability distribution (a vector), then $p^{(0)}P^{(m)}$ is the
            probability distribution after $m$ timesteps.

            The return times of a state $i$ is $R_i = \{m\ |\ p^{(m)}_{ii} > 0 \}$,
            and $i$ is \textit{aperiodic} if $\gcd(R_i) = 1$. A MC is aperiodic if
            any of its vertices is aperiodic. A MC is \textit{irreducible} if the
            corresponding graph is strongly connected.

            A distribution $\pi$ is stationary if $\pi P = \pi$. If MC is
            irreducible then $\pi_i = 1/\mathbb{E}[T_i]$, where $T_i$ is the
            expected time between two visits at $i$. $\pi_j/\pi_i$ is the expected
            number of visits at $j$ in between two consecutive visits at $i$. A MC
            is \textit{ergodic} if $\lim_{m\to\infty} p^{(0)} P^{m} = \pi$. A MC is
            ergodic iff.\ it is irreducible and aperiodic.

            A MC for a random walk in an undirected weighted graph (unweighted
            graph can be made weighted by adding $1$-weights) has $p_{uv} =
            w_{uv}/\sum_{x} w_{ux}$. If the graph is connected, then $\pi_u =
            \sum_{x} w_{ux} / \sum_{v}\sum_{x} w_{vx}$. Such a random walk is
            aperiodic iff.\ the graph is not bipartite.

            An \textit{absorbing} MC is of the form $P = \left(\begin{matrix} Q & R
            \\ 0 & I_r \end{matrix}\right)$. Let $N = \sum_{m=0}^\infty Q^m = (I_t
            - Q)^{-1}$. Then, if starting in state $i$, the expected number of
            steps till absorption is the $i$-th entry in $N1$. If starting in state
            $i$, the probability of being absorbed in state $j$ is the $(i,j)$-th
            entry of $NR$.

            Many problems on MC can be formulated in terms of a system of
            recurrence relations, and then solved using Gaussian elimination.

        \subsection{Burnside's Lemma}
            Let $G$ be a finite group that acts on a set $X$. For each $g$ in $G$
            let $X^g$ denote the set of elements in $X$ that are fixed by $g$. Then
            the number of orbits \[ |X/G| = \frac{1}{|G|} \sum_{g\in G} |X^g| \]

            \[
                Z(S_n) = \frac{1}{n} \sum_{l=1}^n a_l Z(S_{n-l})
            \]

        \subsection{Bézout's identity}
            If $(x,y)$ is any solution to $ax+by=d$ (e.g.\ found by the Extended
            Euclidean Algorithm), then all solutions are given by \[
            \left(x+k\frac{b}{\gcd(a,b)}, y-k\frac{a}{\gcd(a,b)}\right) \]

        \subsection{Misc}
            \subsubsection{Determinants and PM}
                \begin{align*}
                    det(A) &= \sum_{\sigma \in S_n}\text{sgn}(\sigma)\prod_{i = 1}^n a_{i,\sigma(i)}\\
                    perm(A) &= \sum_{\sigma \in S_n} \prod_{i = 1}^n a_{i,\sigma(i)}\\
                    pf(A) &= \frac{1}{2^nn!}\sum_{\sigma \in S_{2n}} \text{sgn}(\sigma)\prod_{i = 1}^n a_{\sigma(2i-1),\sigma(2i)}\\ &= \sum_{M \in \text{PM}(n)} \text{sgn}(M) \prod_{(i,j) \in M} a_{i,j}
                \end{align*}

            \subsubsection{BEST Theorem}
                Count directed Eulerian cycles. Number of OST given by
                Kirchoff's Theorem (remove r/c with root) $\#\textsc{OST}(G,r)
                \cdot \prod_{v}(d_v-1)!$

            \subsubsection{Primitive Roots}
                Only exists when $n$ is $2, 4, p^k, 2p^k$, where $p$ odd prime. Assume
                $n$ prime. Number of primitive roots $\phi(\phi(n))$
                Let $g$ be primitive root. All primitive roots are of the form $g^k$
                where $k,\phi(p)$ are coprime.\\ $k$-roots:
                $g^{i \cdot \phi(n) / k}$ for $0 \leq i < k$

            \subsubsection{Sum of primes} For any multiplicative $f$:
                \[
                    S(n,p) = S(n, p-1) - f(p) \cdot (S(n/p,p-1) - S(p-1,p-1))
                \]

            \subsubsection{Floor}
                \begin{align*}
                    &\left\lfloor \left\lfloor x/y \right\rfloor / z \right\rfloor = \left\lfloor x / (yz) \right\rfloor \\
                    &x \% y = x - y \left\lfloor x / y \right\rfloor
                \end{align*}



    \clearpage
    \section*{Practice Contest Checklist}
        \begin{itemize}
            \item How many operations per second? Compare to local machine.
            \item What is the stack size?
            \item How to use printf/scanf with long long/long double?
            \item Are \texttt{\_{}\_{}int128} and \texttt{\_{}\_{}float128} available?
            \item Does MLE give RTE or MLE as a verdict? What about stack overflow?
            \item What is \texttt{RAND\_{}MAX}?
            \item How does the judge handle extra spaces (or missing newlines) in the output?
            \item Look at documentation for programming languages.
            \item Try different programming languages: C++, Java and Python.
            \item Try the submit script.
            \item Try local programs: i?python[23], factor.
            \item Try submitting with \texttt{assert(false)} and \texttt{assert(true)}.
            \item Return-value from \texttt{main}.
            \item Look for directory with sample test cases.
            \item Make sure printing works.

            \item Remove this page from the notebook.
        \end{itemize}
\end{multicols*}
\end{document}
